1.  The name I used in the program:
    Chuhan Feng

2.  A valid serial number associated with my name:
    c326-1176-0a5b-7d43

3.  Details about the program and my solution:

    * About the program:

        I disassembled two key functions to this program. One is main() function,
        the other is test_key() function. The disassembled codes and all explanations
        can be found in the file named disassembly.c. The procedure I describe below
        is based on the disassembled code in disassembly.c.

        The procedure of the program:
        - The program prompt for a name in the beginning.
        - Then the name is converted into lowercase.
        - The program then ask for a serial number.
        - The program stores the serial number into four parts: s1, s2, s3, s4.
        - Next, the program will call a function named test_key(), which takes name,
          s1, s2, s3, and s4 as parameters.
        - In the beginning of function test_key(), a loop runs six time. For each time,
          the value of s4 is updated with different operation.
          Those operations are: (notice that the third and fourth can be eliminated)
          s4 += 0x8086;
          s4 ^= 0x8086;
          s4 -= 0x8086;
          s4 += 0x8086;
          s4 -= 0x8086;
          s4 ^= 0x8086;
        - Right after that, another loop iterates through all characters in name.
          The following operations will be done for each character c in name:
          s1 -= c;
          s2 -= c;
          s3 += c;
          s4 += c;
        - Finally, the function will check if the computed value of s1, s2, s3, s4
          satisfy the following constraints:
          s1 == 0xbeef
          s2 * s3 == 0xc0ffee
          s4 == 0x8086
          If all constraints are met, the function returns 1, otherwise returns 0.
        - The main function will then check the return value of test_key().
          If the return value is 1, the program will print "Key accepted."
          Otherwise, the program will print "Invalid key."

    * About my solution:

        A solution can be found by reversing the procedure above.

        The procedure of the solution:
        - First of all I need to factorize 0xc0ffee in order to to find feasible
          values for s2 and s3. Suppose 0xc0ffee is factorized into f1 and f2.
        - Then let:
          s1 = 0xbeef;
          s2 = f1;
          s3 = f2;
          s4 = 0x8086;
        - Then convert the name into lowercase and calculate the sum of all char
          in name.
        - After getting the sum:
          s1 += sum;
          s2 += sum;
          s3 -= sum;
          s4 -= sum;
        - Then:
          s4 ^= 0x8086;
          s4 += 0x8086;
          s4 ^= 0x8086;
          s4 -= 0x8086;
        - Finally, the solution will be "s1-s2-s3-s4".

        Some more detail about my solution can be found at the end of the file
        named disassembly.c. I also implemented the solution as a Ruby program in
        serial_generator.rb file. My solution program can be run with the command
        "ruby serial_generator.rb", and it can be used to generate a valid serial
        number for any name.

4.  Details about how I arrived at my solution:

    Tools I used:
    There are two main tools that I used to analyze the program, they are gdb and
    a disassembler program.
    The disassembler program I used is called "Hopper disassembler", which is very
    similar to IDA. I used it to disassemble the executable program and analyze the
    procedures inside it.
    I also used gdb to track through some tricky part of the program step by step
    to see how does that part actually executed as well as how do data stored and
    converted in that procedure.

    Detailed procedure:
    In the beginning, I disassembled the program with Hopper. I quickly found the main
    function of the program. When I looked through the main function, I found that
    there are two function at the end of main function that seems very important,
    one called correct(), the other called incorrect(). Either of these two functions
    will be called according to a condition stored in eax. I also found that, if
    correct() is called, the key will be accepted, otherwise, the key is invalid.
    So the key to this program is the value stored in eax, which is found to be
    generated by a function called __TMC_END__(or test_key, I don't know why it has
    two names). Hence, in order to solve the serial number, both main function and
    __TMC_END__ should be further analyzed. Firstly I solved the main function.
    Basically, what it does is to prompt for a name and four serial numbers, then
    convert the name into lowercase. The function __TMC_END__ will then read in
    the name and four serial numbers and determine whether it's a valid combination.
    After that, when I analyze __TMC_END__, I met a problem with a very strange
    loop. I cannot figure out where it jumps to. Also, there is an "and" instruction
    which make it seems impossible to find a solution. I was so confused and decided
    to use gdb to track the program when it's running. I found that the loop is used
    to change the program itself on running time, and the "and" instruction will
    never be executed since that. Finally I solved the function __TMC_END__ and
    converted it into a readable c code in disassembly.c. In order to find the solution,
    I wrote a program named serial_generator.rb which can generate a valid serial
    number for me. The algorithm inside serial_generator.rb is the reversed version
    of algorithm in disassembly.c. I tested the serial number generated by my generator
    for different names. I modified the generator until all test passed, and my
    solution is found.


